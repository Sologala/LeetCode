![](https://github.com/Sologala/SomeThings/blob/master/face.jpg?raw=true)
/*
    Sologala   @github    https://github.com/Sologala/LeetCode.git
    LeetCode   172. 阶乘后的零
*/

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

##**思路：** 

​	这道题……..感觉不像是简单题0-0。还是要转个弯才能想到。

​	最直观的想法 直接把数字的阶乘算出来，但是这样稳稳的上溢。

​	比如5 的阶乘是`120` 后面有一个0. 为了统计处这样的0 有多少个。我们只需要知道所有可能的数字 里面相乘 可以得到10 的个数。

​	比如`5! = 5*4*3*2*1` 其中 5*2得到10；这就是最后一个0 的来源/

​	在思考一下，要得到整数10  只能由 2*5 得到，我们可以把问题转换成为 寻找`<n` 的所有数字中 的分解 因子中的2 和5 的个数。一个2和一个5 就能构成10 。

​	比如`10！ =(2*5)*9*(2*4)*7*(2*3)*(5*1)*(2*2)*3*(2*1)`

​	其中有 6个`2` 2个`5` 只能构成两个10 所以 `10` 的结果应该是2 。

   并且我们发现统计`2`的个数没有意义的。2 的个数必然比5 多。因此我们只需要统计5 的个数就行了。

​    如何统计5的个数。

​	例如 `30` 它的5 的来源只能是`5，10，15，20，25，30`中得到。总共应该是7个。(25 =5*5)

​	公式为 `n+=n/5`;

​	`30 =30/5+6/5 =6+1 =7`

 	 

### **ac_code**
```c
int trailingZeroes(int max) {
        int ret =0;
        while(max>1)
            ret+=(max /=5);
        return ret;
	}
```

为了速度快点还可以 设置一个除法结果的数组。这样计算除法回快点，但是还是撵不上 排名上的大佬，不知道为啥他们的可以这么快。