![face.jpg](https://pic.leetcode-cn.com/5f44c38cfca16ba4f3886e1c9e298c5ab18a215dc25e965ec357a430e783b3af-face.jpg)

/*
    Sologala   @github    https://github.com/Sologala/LeetCode.git

   [523]连续的子数组和
     |     continuous-subarray-sum

*/



## **Solution** 

###### 方法1 

​	暴力枚举所有的部分和看是否能够整除 `k` 能过但是时间复杂度很高`O(n^2)`

###### O(n)解法







执行用时 :28 ms, 在所有 C++ 提交中击败了99.29%的用户

内存消耗 :11.4 MB, 在所有 C++ 提交中击败了46.10%的用户

### **ac_code**
```c

class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> m;
        if(nums.size()<=1) return false;
        k = (k < 0? -k : k);
        if(k==1) return true;
        k = (k == 0 ? 1000000007 : k);
        int cur =0;
        for(int i = 0;i<nums.size();++i){
            cur =  (cur + nums[i]);
            if(cur== k&&i>0) return true;
            int idx = m[cur%k];
            if(idx)
            {
                if(i - idx + 1 > 1) return true;
            }
            else m[cur%k] = i + 1;
        }
        return cur == 0;
    }
};
```