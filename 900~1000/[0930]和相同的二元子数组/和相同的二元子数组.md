![](https://github.com/Sologala/SomeThings/blob/master/face.jpg?raw=true)
/*
    Sologala   @github    https://github.com/Sologala/LeetCode.git
    LeetCode   和相同的二元子数组
   |     binary-subarrays-with-sum

*/

在由若干 `0` 和 `1`  组成的数组 `A` 中，有多少个和为 `S` 的**非空**子数组。

 

**示例：**

```
输入：A = [1,0,1,0,1], S = 2
输出：4
解释：
如下面黑体所示，有 4 个满足题目要求的子数组：
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
```

 

**提示：**

1. `A.length <= 30000`
2. `0 <= S <= A.length`
3. `A[i]` 为 `0` 或 `1`

##**Solution** 

```c
[1,0,1,0,1,0]//例如像这种序列
S = 2
```

​	我们可以统计每个非`0`数字左边的 `0` 的数量 以及 右边的 `0` 的数量，因为 `0` 不会对一个区间的和产生影响。而要构成我们 `S = 2` 则需要至少两个 1 。 我们可以求出第一个`1` 左边的`0`的个数，以及最后一个 `1` 的右边的 `0` 的个数 然后它们相乘 就是的当前这两个`1` 构成 `s`的所有总类。

例如  在上例中的前两个 `1`

**1** 0 **1** 0 1 0 存在 1 0 1 和  1 0 1 0  两种  （`L[i]` 表示第`i`个数字左边的`0`的个数，`R[i]`同理

```c
L[1] = 0  R[2] = 1  res = (L[1]+1) * (R[2] + 1) = (0 + 1) * (1 + 1) = 2
```

1 0 **1** 0 **1** 0  存在 1 0 1 和  0 1 0 1  和 1 0 1  0以及  0 1 0 1 0 四种

```
L[1] = 1  R[2] = 1  res = (L[1]+1) * (R[2] + 1) = (1 + 1) * (1 + 1) = 4
```

到这里，貌似我们解决了问题 ，我们只需要先统计一遍`S`个 `i` 中第一个 `1` 左的 和最后一个 `i` 右的 `0` 的个数，但是提交之后发现。

会出现这种情况

``` c
[0,1,0,0,0]//例如像这种序列
S = 0
```

当我们的`S == 0` 的时候，会和我们之前的思路完全不一样。

对于想要求的和是 `0` 这种情况，我们需要统计 序列中连续的 `0` 的个数，然后对他使用 累加和公式，就能求出这一段连续的 `0` 总共能有多少种 。

例如 `0 0 0` 就会有 `(cnt + 1) * cnt / 2` 种 `0` 的组合。 

因此我们要对于 `S = 0` , 进行一个特别的判断。

###  **ac_code**

```c
int L[30001] = {};
int R[30001] = {};

class Solution {
public:
    int numSubarraysWithSum(vector<int>& A, int S) {
        int ret = 0;
        if(S==0){//需要找的数字是0 的情况
            int cnt = 0;//判断连续的0的情况。
            for(int i = 0;i<A.size();++i){
                if(A[i]==0){
                    cnt++;
                }
                else{
                    ret += (cnt+1)*cnt/2;//累加和公式。
                    cnt = 0;
                }
            }
            ret += (cnt+1)*cnt/2;
        }
        else{
            vector<int> rec;
            int cnt = 0;
            for(int i = 0;i<A.size();++i){
                if(A[i]==1){
                    if(rec.size()){
                        R[rec.back()] = cnt;//设置上一个1的R
                    }
                    rec.push_back(i);//记录1 的下标
                    L[i] = cnt;
                    cnt = 0;
                }
                else{
                    cnt++;
                }
            }
            if(rec.size()){//如果已经出想过1了，防止没有一个1的情况back越界
                R[rec.back()] = cnt;//处理最后一个数字的R
            }
            for(int i = S-1;i<rec.size();++i){//设置一个 S 个 1 的窗口。
                ret += (L[rec[i- S + 1]]+1) * (R[rec[i]]+1);
            }
        }
        return ret;
    }
};
```