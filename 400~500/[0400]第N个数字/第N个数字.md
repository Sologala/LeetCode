![](https://github.com/Sologala/SomeThings/blob/master/face.jpg?raw=true)
/*
    Sologala   @github    https://github.com/Sologala/LeetCode.git
    LeetCode   第N个数字
   |     nth-digit

*/

在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 *n* 个数字。

**注意:**
*n* 是正数且在32为整形范围内 ( *n* < 231)。

**示例 1:**

```
输入:
3

输出:
3
```

**示例 2:**

```
输入:
11

输出:
0

说明:
第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。
```

##**Solution** 



 首先来观察一下规律

```c
/*
	[   0 ~    9] : 位数 1  数字 9
	[  10 ~   99] : 位数 2  数字 180
	[ 100 ~  999] : 位数 3  数字 2700
	[1000 ~ 9999] : 位数 4  数字 36000
*/
```

以此类推，可以得到之后的每个区间的数字 的个数

使用一个数组来存储这些信息，然后从头开始遍历这个数组，依次判断是否在当前这个区间内部 。

`cnt[i]` 代表的区间是 `pow(10,i) ~ pow(10,i+1) - 1`  

如果我们找到某个区间包含咋们 的 `n` 可以 使用 `(n-1)/(i+1)` 来求到是`pow(10,i) ~ pow(10,i+1) - 1`   中的哪个数字。

最后我们把这个数字 转换成字符串 ，在拿到  `(n-1)%(i+1)` 的字符就是我们想要的数字了。

###  **ac_code**
```c
class Solution {
public:
    int findNthDigit(int n) {
        const static int cnt[] = {9,180,2700,36000,450000,5400000,63000000,720000000,2147483647};
        for(int i=0;i<10;i++){
            if(n<=cnt[i]){
                int num = pow(10,i) + (n-1)/(i+1);
                int b = (n-1)%(i+1);
                return  to_string(num)[b]-'0';
            }
            n-=cnt[i];//排除前一个阶段的
        }
        return -1;
    }
};
```