![](https://github.com/Sologala/SomeThings/blob/master/face.jpg?raw=true)
/*
    Sologala   @github    https://github.com/Sologala/LeetCode.git
    LeetCode   最大矩形
   |     maximal-rectangle

*/

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

**示例:**

```c
输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6
```

##**Solution** 

这道题我们需要一行一行去处理这些矩形，例如示例 输 入中

```c
  [1 , 0 , 1 , 0 , 0 ],
  [1 , 0 , 1 , 1 , 1 ],
  [1 , 1 , 1 , 1 , 1 ],
  [1 , 0 , 0 , 1 , 0 ]
```

第一行 中 

```c 
[1 , 0 , 1 , 0 , 0 ],
```

我们可以观察到最 宽 的 高度(面积是长 X 宽 ，由于我们这里是从上往下开始计算，所以当作是高 ) 是 `1` 所以当前这一行的最大的面积是 ` 1 X 1 = 1  `

第二行 

``` c
[2 , 0 , 2 , 1 , 1 ],
```

我们把第一行中的数据  加到  第二行中来，其中的 2 0 **2 1 1**  是最宽的宽度 为 `3` 而他的宽度为 `3` 的 高度是 `1` ， 所以第一行 加上第二行的最大的矩形面积是 `3 X 1 = 3` 

 第三行 

``` c
[3 , 1 , 3 , 2 , 2 ],
```

我们把第三行的数据也加起来，现在就要考虑钱三行的情况了，但是这个时候不能直接考虑最宽的一种高度了 ，可以发现这里最宽 为 `1` 但是他的面积只能是 `5` ，而正确的面积应该是 `6` ，也就是我们的 3 1 **3 2 2** 取高度 `2` 宽度 `3` 。

所以我们可以在计算的时候可以分别统计高度为 `x` 的最宽的宽度是多少，存放在`rec_max[x]`中，之后我们在求出的 最大的乘积 ，也就是我们当前最大的矩形的面积了。

具体可以通过遍历这个数组 `for(int i = 0;i < v.size(); ++i)`

通过一个数据栈来存储

``` c
int rec[max_h + 1] = {};//记录某个高度的矩形的宽度。
int top = 0;
```

当 当前的这个数字比栈顶 `top` 的值 小 的时候就证明 更加高的应该要被舍弃了 。所以要把它们都清空。

```c
 while(top!=0&&v[i]<top){
     rec[top--] = 0;
 }
```



那么在最外层的循环里面 对每一层的数据都进行一次计算，就能得到最大的一个矩形的面积。

那么在这个过程中记录下来最大的一个 面积 就行了。

### **ac_code**
```c
class Solution {
public:
    
    int findMaxRectangle(vector<int> & v, int max_h){
        int rec[max_h + 1] = {};//记录某个高度的矩形的宽度。
        int top = 0;//参数max_h 代表当前的最深，也就是 i
        int max_ret = 0;
        for(int i = 0;i < v.size(); ++i){
            while(top!=0&&v[i]<top){
                rec[top--] = 0;//清空
            }
            top  = v[i];
            for(int j = 1;j <= top ; j++){
                rec[j]++;//小于top的都得加一层
                max_ret = max( max_ret , j * rec[j]);
            }
        }
        return max_ret;
    }
    
    int maximalRectangle(vector<vector<char>>& matrix) {
        int ret =  0;
        if(matrix.size() == 0) return 0;
        vector<int> rec_high(matrix[0].size(),0);//用来记录当前最每一位置的高度
        for(int i = 0;i<matrix.size();++i){
            for(int j = 0;j<matrix[i].size();++j){//上一层坐 到下一层来。
                rec_high[j] = (matrix[i][j]=='1') ? rec_high[j]+ 1: 0;
            }
            ret = max(ret, findMaxRectangle(rec_high,i + 1));
        }
        return ret;
    }
};
```